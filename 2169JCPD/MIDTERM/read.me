
Server.js
This activity provided hands-on experience setting up a fundamental Express.js server. The goal was to configure the server to listen on port 3000 and respond to incoming requests with a simple "Hello World!" message. This exercise was an introduction to the core principles of web routing and server-client communication, teaching me how to get a basic server up and running and send an initial response.


Server2.js
In this activity, I created a second Express.js server to run concurrently on a separate port (2001). It was configured to serve a unique message, which demonstrated the ability to manage and operate multiple independent server instances simultaneously. The key takeaway was understanding how to customize server configurations and response content for different services or applications.


Server3.js
This exercise focused specifically on handling a GET request within an Express.js application running on port 4000. I configured a route to listen for this type of request and send back a message confirming the method used. The primary lesson was a deeper understanding of the GET HTTP method, which is essential for retrieving information from a server, and how to program a server to handle it appropriately.


Server4.js
This final activity was about configuring an Express.js server to serve static content, such as image files. I learned how to use the express.static middleware to make a designated folder of assets accessible to the client's browser. This is a crucial skill for web development, as it allows for efficient delivery of non-dynamic resources like images, stylesheets, and scripts, ultimately contributing to better application performance and user experience. The activity provided practical insight into combining dynamic routing with static file serving.
